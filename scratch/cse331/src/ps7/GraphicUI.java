package ps7;

import java.awt.*;
import java.util.*;

import ps2.*;
import ps4.StreetClassification;
import ps4.StreetSegment;
import ps6.*;

/**
 * <p>
 * Graphical interface for HuskyMaps.  Valid command line arguments can displayed with
 * the single flag '-h'.
 * </p>
 * <p>
 * All construction of GUI components handled by auto-generated code of NetBeans IDE 6.9.1 .
 * The accompanying GraphicUI.form file details the front-end construction of the GUI window and
 * all its components.
 * </p>
 */
public class GraphicUI extends javax.swing.JFrame {
	
	/** switch to turn on debugging reporting for the class during runtime, printed to the console */
	private static boolean DEBUG = false;
	/** switch to turn on hard-coded database and address selections for the class during runtime */
	private static boolean DEBUG_SETDB = false;
	/** hard coded database source, for debugging */
	private static String DEBUG_DB = "/cse/courses/cse331/tigerdb/medium";
	/** hard coded start address, for debugging */
	private static Address DEBUG_START = new Address(19696, "Echo Lake Pl N", "98133");
	/** hard coded end address, for debugging */
	private static Address DEBUG_END = new Address(23304, "59th Pl S", "98032");
	
	
	
    /** Creates new form file GraphicUI */
    public GraphicUI() {
        initComponents();
        jPanelAddr.setVisible(false);
        jButtonDBToAddr.setVisible(false);
        jFrameMap.setVisible(false);

        selectedFormat = 0;
        quickSearch = false;
    	textFieldDefaults = setFieldDefaults();
    	textFieldCurrents = setFieldDefaults();;

    }
    
    /** helper to keep track of the default values of the GUI text fields */
    private Map<javax.swing.JTextField, String> setFieldDefaults(){
    	Map<javax.swing.JTextField, String> map = new HashMap<javax.swing.JTextField, String>();
    	
    	map.put(jFieldDBFile, "enter folder path");
    	map.put(jTextFieldZipcodes, "zipcode1, zipcode2, etc");
    	map.put(jTextFieldStart, "address street zipcode");
    	map.put(jTextFieldEnd, "address street zipcode");
    	
    	return map;
    }

    /** This method is called from within the constructor to
     * initialize the form file.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jDesktopPane1 = new javax.swing.JDesktopPane();
        jFrameMap = new javax.swing.JFrame();
        mapPanel = new javax.swing.JPanel();
        jPanelDB = new javax.swing.JPanel();
        jButtonDBToAddr = new javax.swing.JButton();
        jLabelHMTitle = new javax.swing.JLabel();
        jButtonHMExit = new javax.swing.JButton();
        jPanelDBLoad = new javax.swing.JPanel();
        jLabelDBHead = new javax.swing.JLabel();
        jFieldDBFile = new javax.swing.JTextField();
        jButtonDBLoad = new javax.swing.JButton();
        jCheckBoxZipFilter = new javax.swing.JCheckBox();
        jTextFieldZipcodes = new javax.swing.JTextField();
        jPanelAddr = new javax.swing.JPanel();
        jButtonAddrToDB = new javax.swing.JButton();
        jPanelAddrInfo = new javax.swing.JPanel();
        jTextFieldEnd = new javax.swing.JTextField();
        jLabelStart = new javax.swing.JLabel();
        jLabelEnd = new javax.swing.JLabel();
        jTextFieldStart = new javax.swing.JTextField();
        jLabelShowDB = new javax.swing.JLabel();
        jPanelFormat = new javax.swing.JPanel();
        jLabelFormatHead = new javax.swing.JLabel();
        jComboBoxFormat = new javax.swing.JComboBox();
        jCheckBoxQuickSearch = new javax.swing.JCheckBox();
        jLabelHMTitle1 = new javax.swing.JLabel();
        jButtonGetDirections = new javax.swing.JButton();
        jCheckBoxHideStreetNames = new javax.swing.JCheckBox();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextAreaResults = new javax.swing.JTextArea();

        jFrameMap.setTitle("Husky Maps:  Map View");
        jFrameMap.setMinimumSize(new java.awt.Dimension(100, 100));

        mapPanel.setBackground(new java.awt.Color(254, 254, 254));
        mapPanel.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        mapPanel.setPreferredSize(new java.awt.Dimension(500, 300));
        mapPanel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                mapPanelMouseReleased(evt);
            }
        });
        mapPanel.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                mapPanelMouseDragged(evt);
            }
        });

        javax.swing.GroupLayout mapPanelLayout = new javax.swing.GroupLayout(mapPanel);
        mapPanel.setLayout(mapPanelLayout);
        mapPanelLayout.setHorizontalGroup(
            mapPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 496, Short.MAX_VALUE)
        );
        mapPanelLayout.setVerticalGroup(
            mapPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 296, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout jFrameMapLayout = new javax.swing.GroupLayout(jFrameMap.getContentPane());
        jFrameMap.getContentPane().setLayout(jFrameMapLayout);
        jFrameMapLayout.setHorizontalGroup(
            jFrameMapLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jFrameMapLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(mapPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        jFrameMapLayout.setVerticalGroup(
            jFrameMapLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jFrameMapLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(mapPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Husky Maps:  Controls");

        jPanelDB.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jPanelDB.setPreferredSize(new java.awt.Dimension(400, 251));

        jButtonDBToAddr.setLabel("Back to Current");
        jButtonDBToAddr.setMaximumSize(new java.awt.Dimension(130, 29));
        jButtonDBToAddr.setMinimumSize(new java.awt.Dimension(130, 29));
        jButtonDBToAddr.setPreferredSize(new java.awt.Dimension(130, 29));
        jButtonDBToAddr.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonDBToAddrActionPerformed(evt);
            }
        });

        jLabelHMTitle.setFont(new java.awt.Font("Arial Black", 3, 24));
        jLabelHMTitle.setText("Husky Maps!");

        jButtonHMExit.setText("Exit");
        jButtonHMExit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonHMExitActionPerformed(evt);
            }
        });

        jLabelDBHead.setText("Enter Database Source:");

        jFieldDBFile.setForeground(new java.awt.Color(170, 170, 170));
        jFieldDBFile.setText("enter folder path");
        jFieldDBFile.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jFieldDBFileFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                jFieldDBFileFocusLost(evt);
            }
        });

        jButtonDBLoad.setText("Load Database");
        jButtonDBLoad.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonDBLoadActionPerformed(evt);
            }
        });

        jCheckBoxZipFilter.setText("Filter zipcodes?");

        jTextFieldZipcodes.setForeground(new java.awt.Color(170, 170, 170));
        jTextFieldZipcodes.setText("zipcode1, zipcode2, etc");
        jTextFieldZipcodes.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jTextFieldZipcodesFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                jTextFieldZipcodesFocusLost(evt);
            }
        });

        javax.swing.GroupLayout jPanelDBLoadLayout = new javax.swing.GroupLayout(jPanelDBLoad);
        jPanelDBLoad.setLayout(jPanelDBLoadLayout);
        jPanelDBLoadLayout.setHorizontalGroup(
            jPanelDBLoadLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelDBLoadLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelDBLoadLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jFieldDBFile, javax.swing.GroupLayout.DEFAULT_SIZE, 375, Short.MAX_VALUE)
                    .addComponent(jLabelDBHead)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelDBLoadLayout.createSequentialGroup()
                        .addGroup(jPanelDBLoadLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanelDBLoadLayout.createSequentialGroup()
                                .addComponent(jTextFieldZipcodes, javax.swing.GroupLayout.DEFAULT_SIZE, 202, Short.MAX_VALUE)
                                .addGap(30, 30, 30))
                            .addGroup(jPanelDBLoadLayout.createSequentialGroup()
                                .addComponent(jCheckBoxZipFilter)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)))
                        .addComponent(jButtonDBLoad, javax.swing.GroupLayout.PREFERRED_SIZE, 143, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        jPanelDBLoadLayout.setVerticalGroup(
            jPanelDBLoadLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelDBLoadLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabelDBHead)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jFieldDBFile, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelDBLoadLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelDBLoadLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jButtonDBLoad)
                        .addComponent(jCheckBoxZipFilter))
                    .addGroup(jPanelDBLoadLayout.createSequentialGroup()
                        .addGap(28, 28, 28)
                        .addComponent(jTextFieldZipcodes, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(24, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout jPanelDBLayout = new javax.swing.GroupLayout(jPanelDB);
        jPanelDB.setLayout(jPanelDBLayout);
        jPanelDBLayout.setHorizontalGroup(
            jPanelDBLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelDBLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabelHMTitle)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 52, Short.MAX_VALUE)
                .addComponent(jButtonDBToAddr, javax.swing.GroupLayout.PREFERRED_SIZE, 146, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelDBLayout.createSequentialGroup()
                .addContainerGap(310, Short.MAX_VALUE)
                .addComponent(jButtonHMExit, javax.swing.GroupLayout.PREFERRED_SIZE, 79, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
            .addGroup(jPanelDBLayout.createSequentialGroup()
                .addGap(2, 2, 2)
                .addComponent(jPanelDBLoad, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanelDBLayout.setVerticalGroup(
            jPanelDBLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelDBLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelDBLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabelHMTitle)
                    .addComponent(jButtonDBToAddr, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanelDBLoad, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jButtonHMExit)
                .addGap(36, 36, 36))
        );

        jPanelAddr.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jPanelAddr.setPreferredSize(new java.awt.Dimension(400, 251));

        jButtonAddrToDB.setLabel("Database select");
        jButtonAddrToDB.setMaximumSize(new java.awt.Dimension(130, 29));
        jButtonAddrToDB.setMinimumSize(new java.awt.Dimension(130, 29));
        jButtonAddrToDB.setPreferredSize(new java.awt.Dimension(130, 29));
        jButtonAddrToDB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonAddrToDBActionPerformed(evt);
            }
        });

        jTextFieldEnd.setForeground(new java.awt.Color(170, 170, 170));
        jTextFieldEnd.setText("address street zipcode");
        jTextFieldEnd.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jTextFieldEndFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                jTextFieldEndFocusLost(evt);
            }
        });

        jLabelStart.setText("Start Address:");

        jLabelEnd.setText("Destination:");

        jTextFieldStart.setForeground(new java.awt.Color(170, 170, 170));
        jTextFieldStart.setText("address street zipcode");
        jTextFieldStart.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jTextFieldStartFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                jTextFieldStartFocusLost(evt);
            }
        });

        jLabelShowDB.setText("Current Database: ");

        javax.swing.GroupLayout jPanelAddrInfoLayout = new javax.swing.GroupLayout(jPanelAddrInfo);
        jPanelAddrInfo.setLayout(jPanelAddrInfoLayout);
        jPanelAddrInfoLayout.setHorizontalGroup(
            jPanelAddrInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelAddrInfoLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelAddrInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabelShowDB)
                    .addGroup(jPanelAddrInfoLayout.createSequentialGroup()
                        .addGroup(jPanelAddrInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabelEnd)
                            .addComponent(jLabelStart))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelAddrInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jTextFieldEnd, javax.swing.GroupLayout.DEFAULT_SIZE, 261, Short.MAX_VALUE)
                            .addComponent(jTextFieldStart, javax.swing.GroupLayout.DEFAULT_SIZE, 261, Short.MAX_VALUE))))
                .addContainerGap())
        );
        jPanelAddrInfoLayout.setVerticalGroup(
            jPanelAddrInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelAddrInfoLayout.createSequentialGroup()
                .addComponent(jLabelShowDB)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelAddrInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldStart, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabelStart))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelAddrInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabelEnd)
                    .addComponent(jTextFieldEnd, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );

        jLabelFormatHead.setText("<html>How will you travel?");

        jComboBoxFormat.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "I'm driving", "I'm walking" }));
        jComboBoxFormat.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                jComboBoxFormatFocusLost(evt);
            }
        });

        jCheckBoxQuickSearch.setText("Quick 'n Dirty search");
        jCheckBoxQuickSearch.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jCheckBoxQuickSearchMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout jPanelFormatLayout = new javax.swing.GroupLayout(jPanelFormat);
        jPanelFormat.setLayout(jPanelFormatLayout);
        jPanelFormatLayout.setHorizontalGroup(
            jPanelFormatLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelFormatLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelFormatLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabelFormatHead, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jComboBoxFormat, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jCheckBoxQuickSearch))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanelFormatLayout.setVerticalGroup(
            jPanelFormatLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelFormatLayout.createSequentialGroup()
                .addComponent(jLabelFormatHead, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jComboBoxFormat, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxQuickSearch)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jLabelHMTitle1.setFont(new java.awt.Font("Arial Black", 3, 24));
        jLabelHMTitle1.setText("Husky Maps!");

        jButtonGetDirections.setFont(new java.awt.Font("DejaVu Sans", 0, 17));
        jButtonGetDirections.setText("Find Directions!");
        jButtonGetDirections.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonGetDirectionsActionPerformed(evt);
            }
        });

        jCheckBoxHideStreetNames.setText("Hide street names");

        javax.swing.GroupLayout jPanelAddrLayout = new javax.swing.GroupLayout(jPanelAddr);
        jPanelAddr.setLayout(jPanelAddrLayout);
        jPanelAddrLayout.setHorizontalGroup(
            jPanelAddrLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelAddrLayout.createSequentialGroup()
                .addGroup(jPanelAddrLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAddrLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabelHMTitle1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 52, Short.MAX_VALUE)
                        .addComponent(jButtonAddrToDB, javax.swing.GroupLayout.PREFERRED_SIZE, 146, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jPanelAddrInfo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(jPanelAddrLayout.createSequentialGroup()
                        .addComponent(jPanelFormat, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 30, Short.MAX_VALUE)
                        .addGroup(jPanelAddrLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanelAddrLayout.createSequentialGroup()
                                .addGap(12, 12, 12)
                                .addComponent(jCheckBoxHideStreetNames))
                            .addComponent(jButtonGetDirections, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap())
        );
        jPanelAddrLayout.setVerticalGroup(
            jPanelAddrLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelAddrLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelAddrLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabelHMTitle1)
                    .addComponent(jButtonAddrToDB, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(jPanelAddrInfo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(jPanelAddrLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAddrLayout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanelFormat, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanelAddrLayout.createSequentialGroup()
                        .addGap(12, 12, 12)
                        .addComponent(jButtonGetDirections, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxHideStreetNames)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jTextAreaResults.setColumns(20);
        jTextAreaResults.setEditable(false);
        jTextAreaResults.setRows(20);
        jTextAreaResults.setBorder(javax.swing.BorderFactory.createTitledBorder("Results"));
        jScrollPane1.setViewportView(jTextAreaResults);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanelDB, javax.swing.GroupLayout.DEFAULT_SIZE, 405, Short.MAX_VALUE)
                    .addComponent(jPanelAddr, javax.swing.GroupLayout.DEFAULT_SIZE, 405, Short.MAX_VALUE)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 405, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanelDB, javax.swing.GroupLayout.PREFERRED_SIZE, 252, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanelAddr, javax.swing.GroupLayout.PREFERRED_SIZE, 252, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 46, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents


    
    
    //////////////////////////////////// GUI ACTION EVENT LISTENERS /////////////////
    
    private void jButtonDBLoadActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonDBLoadActionPerformed
        // get user database input
        String db = jFieldDBFile.getText().trim();
        db = db.length() > 20 ? "..."+db.substring(db.length() - 20) : db;
        jLabelShowDB.setText("Current Database:  "+db);
        
    	loadDatabase();

    }//GEN-LAST:event_jButtonDBLoadActionPerformed

    private void jButtonHMExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonHMExitActionPerformed
        System.exit(0);
    }//GEN-LAST:event_jButtonHMExitActionPerformed

    private void jButtonDBToAddrActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonDBToAddrActionPerformed
        jPanelAddr.setVisible(true);
        jPanelDB.setVisible(false);
    }//GEN-LAST:event_jButtonDBToAddrActionPerformed

    private void jButtonAddrToDBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonAddrToDBActionPerformed
        jPanelAddr.setVisible(false);
        jPanelDB.setVisible(true);
    }//GEN-LAST:event_jButtonAddrToDBActionPerformed
    

    private void jButtonGetDirectionsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonGetDirectionsActionPerformed
    	
    	calculateDirections();

    }//GEN-LAST:event_jButtonGetDirectionsActionPerformed
    
    
    private void jTextFieldZipcodesFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jTextFieldZipcodesFocusGained
        prepareTextField(jTextFieldZipcodes);
    }//GEN-LAST:event_jTextFieldZipcodesFocusGained

    private void jTextFieldZipcodesFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jTextFieldZipcodesFocusLost
        resetTextField(jTextFieldZipcodes);
    }//GEN-LAST:event_jTextFieldZipcodesFocusLost

    private void jFieldDBFileFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jFieldDBFileFocusGained
        prepareTextField(jFieldDBFile);
    }//GEN-LAST:event_jFieldDBFileFocusGained

    private void jFieldDBFileFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jFieldDBFileFocusLost
        resetTextField(jFieldDBFile);
    }//GEN-LAST:event_jFieldDBFileFocusLost

    private void jTextFieldStartFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jTextFieldStartFocusGained
        prepareTextField(jTextFieldStart);
    }//GEN-LAST:event_jTextFieldStartFocusGained

    private void jTextFieldStartFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jTextFieldStartFocusLost
        resetTextField(jTextFieldStart);
        checkAddrInputFields();
    }//GEN-LAST:event_jTextFieldStartFocusLost

    private void jTextFieldEndFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jTextFieldEndFocusGained
        prepareTextField(jTextFieldEnd);
    }//GEN-LAST:event_jTextFieldEndFocusGained

    private void jTextFieldEndFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jTextFieldEndFocusLost
        resetTextField(jTextFieldEnd);
        checkAddrInputFields();
    }//GEN-LAST:event_jTextFieldEndFocusLost

    private void jComboBoxFormatFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jComboBoxFormatFocusLost
        checkAddrInputFields();
    }//GEN-LAST:event_jComboBoxFormatFocusLost

    private void mapPanelMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_mapPanelMouseDragged
        // TODO add your handling code here:
    }//GEN-LAST:event_mapPanelMouseDragged

    private void mapPanelMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_mapPanelMouseReleased
        // TODO add your handling code here:
    }//GEN-LAST:event_mapPanelMouseReleased

    private void jCheckBoxQuickSearchMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jCheckBoxQuickSearchMouseClicked
        checkAddrInputFields();
    }//GEN-LAST:event_jCheckBoxQuickSearchMouseClicked
    
    
    /** Prepares the specified text field for user input, erasing the default message */
    private void prepareTextField(javax.swing.JTextField tx){
    	if(textFieldDefaults.get(tx).equals(tx.getText())){
    		tx.setText("");
    		tx.setForeground(Color.BLACK);
    	}
    }
    
    /** If the text field is empty, resets the specified text field to its default message */
    private void resetTextField(javax.swing.JTextField tx){
    	if(tx.getText().equals("")){
    		tx.setForeground(new java.awt.Color(170, 170, 170));
    		tx.setText(textFieldDefaults.get(tx));
        }
    }
    
    /** Checks whether the address selection fields have been changed to something different
     * than the most recent FindDirections call */
    private boolean checkAddrInputFields(){
    	boolean same = textFieldCurrents.get(jTextFieldStart).equals(jTextFieldStart.getText()) &&
				textFieldCurrents.get(jTextFieldEnd).equals(jTextFieldEnd.getText()) &&
				jComboBoxFormat.getSelectedIndex() == selectedFormat &&
				jCheckBoxQuickSearch.isSelected() == quickSearch;
    	
    	if(DEBUG){
    		outputResults("lasts:");
    		outputResults(textFieldCurrents.get(jTextFieldStart));
			outputResults(textFieldCurrents.get(jTextFieldEnd));
			outputResults(""+jComboBoxFormat.getSelectedIndex()); 
			outputResults("nows:");
			outputResults(jTextFieldEnd.getText());
			outputResults(jTextFieldStart.getText());
			outputResults(""+selectedFormat);
    	}
    	
    	if(!same){
    		jButtonGetDirections.setText("Find Directions!");
    	}else{
    		jButtonGetDirections.setText("Refresh Map");
    	}
    	return same;
    }
    
    /** Sets the most recent directions to the current contents of the address 
     * selection fields to. */
    private void setAddrInputFields(){
    	textFieldCurrents.put(jTextFieldStart, jTextFieldStart.getText());
		textFieldCurrents.put(jTextFieldEnd, jTextFieldEnd.getText());
		selectedFormat = jComboBoxFormat.getSelectedIndex();
		quickSearch = jCheckBoxQuickSearch.isSelected();
    }

    /** Prints the specified string to the Results jTextArea, updating area line counts
     * as well. */
    private void outputResults(String s){
    	jTextAreaResults.setRows(jTextAreaResults.getRows()+ s.split("\n").length );
    	jTextAreaResults.setText(jTextAreaResults.getText()+"\n"+s);
    }
    
    
    
    ////////////////////////////////// DIRECTIONS FINDER INTERFACE METHODS //////////////////////
    
    /** Interprets the database-loading text fields to read in a database, including 
     * instantiating a DirectionsFinder object*/
    private void loadDatabase(){
    	
        String db = jFieldDBFile.getText().trim();
        boolean badzip = false;
        
        Collection<String> zf = new LinkedList<String>();
        
        // handle zipcodes if zip filtering specified
        if(jCheckBoxZipFilter.isSelected()){
	        
        	String zips = jTextFieldZipcodes.getText().trim();
	        
	        String[] z = zips.split(",");
	        for(int i = 0; i < z.length; i++){
	        	zf.add(z[i].trim());
	        }
	        
	        for(String s : zf){
	        	if(s.length() != 5){
	        		badzip = true;
	        	}
	        	try{
	        		Integer.parseInt(s);
	        	}catch(NumberFormatException ex){
	        		badzip = true;
	        	}
	        }
	        
        }
        
        // if the zipcode input is bad
        if(badzip){
        	outputResults("Please check your zipcodes.\nA zipcode must be a 5 digit number...\n");
        	jButtonDBLoad.setForeground(new java.awt.Color(255, 37, 37));
        	jButtonDBLoad.setText("Check Zipcodes");
        }else{
	        // attempt to load database
	        try{
	        	
	        	if(DEBUG_SETDB) db = DEBUG_DB;
	        	
	        	jButtonDBLoad.setForeground(Color.BLACK);
	        	jButtonDBLoad.setText("Loading...");
	        	virtualGPS = DirectionsFinder.getDirectionsFinder(db, zf);
	            jButtonDBLoad.setText("Load Database");
	            
	        	jPanelAddr.setVisible(true);
	        	jPanelDB.setVisible(false);
	            jButtonDBToAddr.setVisible(true);
	        	
	        }catch(InvalidDatabaseException ex){
	        	outputResults("Please check the database path.\nThe path name must refer " +
	        			"to a valid Tiger Database...\n");
	            jButtonDBLoad.setForeground(new java.awt.Color(255, 37, 37));
	            jButtonDBLoad.setText("Check Database");
	        }
        }
    	
    }
    
    
    /** handles all directions calculations, including calling DirectionsFinder.getDirections() */
    private void calculateDirections(){
    	
    	Address start = parseAddress(jTextFieldStart);
    	Address end = parseAddress(jTextFieldEnd);
    	if(DEBUG_SETDB){  start = DEBUG_START;   end = DEBUG_END; }
    	
    	
    	if(textFieldDefaults.get(jTextFieldStart).equals(jTextFieldStart.getText())  ||
    			textFieldDefaults.get(jTextFieldEnd).equals(jTextFieldEnd.getText())){
    		outputResults(addressError(null, -5));
    		
    	}else if(start == null || end == null){
    		outputResults(addressError(null, -4));
    		
    	}else{
			try{
				if(!checkAddrInputFields()){
					RouteFormatter format = getTravelFormat();
		            EnvironmentVariables.OPTIMIZE_FOR_PERFORMANCE_ON = jCheckBoxQuickSearch.isSelected();
					
					currDirections = virtualGPS.getDirections(start, end, format);
					// prepare the map view
					if(!jFrameMap.isShowing()){
				        jFrameMap.setVisible(true);
				        jFrameMap.setBounds(this.getX()+this.getWidth(), this.getY(), 
				        		jFrameMap.getPreferredSize().width,
				        		jFrameMap.getPreferredSize().height);
					}
					
					outputResults(formatDirections(format));
					
					setAddrInputFields();
					checkAddrInputFields();
					
				}else{
					mapPanel.requestFocus();
				}
				
		        generateMap();
		        
		        
			}catch(InvalidAddressException ex){
				
		    	int error = virtualGPS.checkAddress(start);
		    	if(error != DirectionsFinder.ADDRESS_VALID){       // if start address is bad
		    		outputResults(addressError(start, error));
		    	
		    	}else{
			    	error = virtualGPS.checkAddress(end);
		    		outputResults(addressError(end, error));
		    	}
		    	
			}catch(NoPathException ex){
				
				outputResults("No path found:\nFrom "+start+"\nTo "+end+"\n");
			}
    	}
    
    }

    
    ///////////////////////////////////////// GUI INPUT PROCESSING METHODS ///////////////////////////////////
    	
    
    /** Interprets the specified text field as an address, and returns the resulting Address 
     * @return null if the address format is invalid
     * */
    private Address parseAddress(javax.swing.JTextField tx){
    	
    	String in = tx.getText().trim();
    	
    	String[] arr = in.split(" ");
    	if(arr.length < 3){
    		return null;
    	}
    	
    	int num;
    	String zip;
    	String name;
    	try{
    		num = Integer.parseInt(arr[0]);
        	zip = arr[arr.length - 1];
        	name = "";
        	for(int i = 1; i < arr.length -1; i++){
        		if(arr[i].length() != 0){
        			name += " "+arr[i];
        		}
        	}
  
    	}catch(Exception ex){
    		return null;
    	}
    	
      	return new Address(num, name.substring(1), zip);
    }
    
    /** helper to handle Address error-reporting 
     * @return a String of the error report */
    private String addressError(Address addr, int cause){

    	if(cause == DirectionsFinder.ADDRESS_VALID){
    		return "Should not have thrown error for "+addr+"\n";
    	}else if(cause == DirectionsFinder.ADDRESS_ZIPCODE_INVALID){
			return "No such zipcode: "+addr+"\n";
		}else if(cause == DirectionsFinder.ADDRESS_STREET_INVALID){
			return "No such street: "+addr+"\n";
		}else if(cause == DirectionsFinder.ADDRESS_NUM_INVALID){
			return "No such number: "+addr+"\n";
		}else if(cause == DirectionsFinder.ADDRESS_NULL){
			return "Address "+addr+" was not entered in the correct format.\nEnter " +
					"the address number, the street name, then a 5 " +
					"digit zipcode...\n";
		}else{  // address is null
			return "Complete your address selection...\n";
		}
    }
    
    /** Returns the UI-specified travel format */
    private RouteFormatter getTravelFormat(){
    	
    	int format = jComboBoxFormat.getSelectedIndex();
    	if(format == 0){
    		return new DrivingRouteFormatter();
    	}else if(format == 1){
    		return new WalkingRouteFormatter();
    	}
    	return null;
    }
    
    
    /** Returns the current directions instructions to output-ready form */
    private String formatDirections(RouteFormatter formatter)
    {
    	if(currDirections == null){
    		throw new IllegalStateException("directions object should not be null at this point");
    	}
    	
		// start the string
    	StringBuilder instruct = new StringBuilder();
		instruct.append("Start at "+currDirections.getStart()+"\n");
		
		Iterator<String> iter = currDirections.iterator();
		while(iter.hasNext()){
			instruct.append(iter.next()+"\n");
		}
		//distinguish between miles and minutes
		if(formatter instanceof WalkingRouteFormatter){
			//output.println("Trip time: " + (Math.round(navigate.getLength()) * 20) + " minutes");
			
			instruct.append("Trip time: "+Math.round(currDirections.getLength()*20)+" minutes\n\n\n");
		}else if(formatter instanceof DrivingRouteFormatter){
			//DecimalFormat printer = new DecimalFormat("#.#"); // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
			
			instruct.append("Trip length: "+(Math.round(currDirections.getLength()*10))/10.0+" miles\n\n\n");
		}else{
			throw new IllegalArgumentException("Directions implementor class not recognized");
		}
		return instruct.toString();
    }
    
    
    ///////////////////////////////////// GRAPHICAL MAP OUTPUT /////////////////////////
    
    
    /** 
     * Draws the graphical map centered on the current directions path (currDirections).
     *   It gives at least a 5% buffer of space from the border of the window to any point 
     *   of the path.  Also fills in all other streets in the view that connect somehow to 
     *   any point of the current path.  Also maintains a minimum viewing boundary of 2 degrees
     *   latitude and 2 degrees longitude (for mono- latitude or longitude paths).  
     */
    private void generateMap(){
        if(currDirections != null){

	    	Point edge = new Point(mapPanel.getWidth(), mapPanel.getHeight());
        	mapPanel.paintImmediately(0, 0, edge.x, edge.y);
	    	
	    	
	    	// setup advanced graphics object
	        Graphics2D g = (Graphics2D)mapPanel.getGraphics();
	        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
	        g.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);

	        
	        Route rt = currDirections.getRoute();
	
	        boolean singleStreet = rt.getGeoSegments().size() == 1;
	        Route contextRoute = (!singleStreet ? rt : 
	        		new Route( virtualGPS.findFullSegment(rt.getEndingGeoSegment()) ) );
	        
	        // calculate the longitude and latitude bounds
	        int[] bounds = calculateCoverage( contextRoute , edge);
	        
	        Collection<StreetSegment> map = virtualGPS.getContext(bounds, contextRoute);
	        
	        
	        // draw every segment of the map
	        g.setColor(Color.GRAY);
	        for(GeoSegment gs : map){
	        	drawSegment(g, bounds, edge, gs);
	        }
	        
	        // draw the path over the produced map in BLUE
	        g.setColor(Color.BLUE);
	        for(GeoFeature gf : rt.getGeoFeatures()){
	            for(GeoSegment gs : gf.getGeoSegments()){
		        	drawSegment(g, bounds, edge, gs);
	            }
	            Point start = derivePoint(bounds, edge, gf.getStart());
	            Point end = derivePoint(bounds, edge, gf.getEnd());
	            
	            int dX = (int)(Math.abs(start.x - end.x) / 2.0);
	            int dY = (int)(Math.abs(start.y - end.y) / 2.0);

                    if(!jCheckBoxHideStreetNames.isSelected()){
                    	g.setFont(new Font(g.getFont().getFontName(), Font.BOLD, g.getFont().getSize()));
                    	g.drawString(gf.getName(), start.x + (start.x<end.x ? dX : -dX),
                    			start.y + (start.y<end.y ? dY : -dY));
                    }
	        }
        }
    }
    
    
    /** Draws the specified GeoSegment in the current Map View panel */
    private void drawSegment(Graphics2D g, int[] bounds, Point edge, GeoSegment gs){
    	StreetSegment stS = ((StreetSegment)gs);
    	float size;
    	if(stS.getStreetClass().equals(StreetClassification.PRIM_HWY)){
    		size = 4;
    	}else if(stS.getStreetClass().equals(StreetClassification.SEC_HWY)){
    		size = 3;
    	}else if(stS.getStreetClass().equals(StreetClassification.LOCAL_ROAD)){
    		size = 2;
    	}else{  // UKNOWN_ROAD
    		size = 1;
    	}
        g.setStroke(new BasicStroke(size, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
    	Point p1 = derivePoint(bounds, edge, gs.getP1());
    	Point p2 = derivePoint(bounds, edge, gs.getP2());
    	g.drawLine(p1.x, p1.y, p2.x, p2.y);
    }
    
    
    /** Helper to calculate the Latitude and Longitude limits of the Map View
     *  panel based on the specified route.  The limits should be calculated
     *  based on the current Map View window's size, and give at least a 5% buffer 
     *  of space from the boarder to any point of the route. */
    private int[] calculateCoverage(Route rt, Point edge){

    	int[] latLonMinMax = new int[4];
    	
        // figure out the bounding box of the route
        latLonMinMax[0] = rt.getStart().getLatitude();
        latLonMinMax[1] = latLonMinMax[0];
        latLonMinMax[2] = rt.getStart().getLongitude();
        latLonMinMax[3] = latLonMinMax[2];
        
        for(GeoSegment gs : rt.getGeoSegments()){
        	int temp = gs.getP2().getLatitude();
        	latLonMinMax[0] = latLonMinMax[0] > temp ? temp : latLonMinMax[0];
        	latLonMinMax[1] = latLonMinMax[1] < temp ? temp : latLonMinMax[1];
        	
        	temp = gs.getP2().getLongitude();
        	latLonMinMax[2] = latLonMinMax[2] > temp ? temp : latLonMinMax[2];
        	latLonMinMax[3] = latLonMinMax[3] < temp ? temp : latLonMinMax[3];
        }
        
        
        // now use aspect ratio of the window to get bounds of the display
        int diffLat = latLonMinMax[1] - latLonMinMax[0];
        int diffLon = latLonMinMax[3] - latLonMinMax[2];
        
        // the longest aspect will be a larger ratio
        double horzAsp = diffLon / edge.getX();
        double vertAsp = diffLat / edge.getY();
        
        double expandLat = 0.0;
        double expandLon = 0.0;
        if(horzAsp > vertAsp){
        	double factor = horzAsp/vertAsp;
        	// calculate the expansion of the short dimension
        	expandLat = ((diffLat * factor - diffLat) / 2.0);
        	expandLat += ((diffLat * factor) / 20.0);  // 20.0 for 5%
        	// long dimension
        	expandLon = diffLon / 20.0;
        }else{
	        double factor = vertAsp/horzAsp;
	    	// calculate the expansion of the short dimension
	    	expandLon = ((diffLon * factor - diffLon) / 2);
        	expandLon += ((diffLon * factor) / 20.0);
        	// long dimension
        	expandLat = diffLat / 20.0;
        }
        
        latLonMinMax[0] -= ( ((int)expandLat) != 0 ? ((int)expandLat) : 2);
        latLonMinMax[1] += ( ((int)expandLat) != 0 ? ((int)expandLat) : 2);
        latLonMinMax[2] -= ( ((int)expandLon) != 0 ? ((int)expandLon) : 2);
        latLonMinMax[3] += ( ((int)expandLon) != 0 ? ((int)expandLon) : 2);
        
    	return latLonMinMax;
    }

    
    /** helper to determine the x,y coordinates of a GeoPoint */
    private Point derivePoint(int[] minMaxLatLon, Point edge, GeoPoint p){
    	int y = (int)((minMaxLatLon[1] - p.getLatitude()) /
    			((double)(minMaxLatLon[1] - minMaxLatLon[0])) *
    			(edge.getY()));
    	
    	int x = (int)((p.getLongitude() - minMaxLatLon[2]) /
    			((double)(minMaxLatLon[3] - minMaxLatLon[2])) *
    			(edge.getX()));
    	
    	return new Point(x, y);
    }
    

    
    /**
     * Initiate an instance of GraphicUI with the specified arguments
    * @param args, for each element of args, the following flags are valid:</br>
    * -h for help text
    * -F to turn on fractional distance, -f to turn off
	* -I to turn on intersection traversal, -i to turn off
	* -C to turn on street classification, -c to turn off
    */
    public static void main(String args[]) {
        if(args.length != 0 && args[0].equals("-h")){
			System.err.println("Set HuskyMaps environment variables!\n" +
					"USAGE:\n" +
					"-F to turn on fractional distance, -f to turn off\n" +
					"-I to turn on intersection traversal, -i to turn off\n" +
					"-C to turn on street classification, -c to turn off");
			return;
		}
        
		for(int i = 0; i < args.length; i++){
			EnvironmentVariables.setFlag(args[i]);
		}
    	
    	java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GraphicUI().setVisible(true);
            }
        });
    }
    
    
    
    
    // Global GUI-DirectionsFinder interaction variables
    /** The DirectionsFinder instance that this UI is operating with */
	private DirectionsFinder virtualGPS;
	/** The most current sequence of directions successfully found */
	private Directions currDirections;
	/** The most recent travel format select */
	private int selectedFormat;
	/** The most recent quick search option selected */
	private boolean quickSearch;
	/** map of text fields to their standard defaults, used as help-text */
	private Map<javax.swing.JTextField, String> textFieldDefaults;
	/** map of text fields to their most recent input for which directions
	 * were successfully found */
	private Map<javax.swing.JTextField, String> textFieldCurrents;
    
    

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonAddrToDB;
    private javax.swing.JButton jButtonDBLoad;
    private javax.swing.JButton jButtonDBToAddr;
    private javax.swing.JButton jButtonGetDirections;
    private javax.swing.JButton jButtonHMExit;
    private javax.swing.JCheckBox jCheckBoxHideStreetNames;
    private javax.swing.JCheckBox jCheckBoxQuickSearch;
    private javax.swing.JCheckBox jCheckBoxZipFilter;
    private javax.swing.JComboBox jComboBoxFormat;
    private javax.swing.JDesktopPane jDesktopPane1;
    private javax.swing.JTextField jFieldDBFile;
    private javax.swing.JFrame jFrameMap;
    private javax.swing.JLabel jLabelDBHead;
    private javax.swing.JLabel jLabelEnd;
    private javax.swing.JLabel jLabelFormatHead;
    private javax.swing.JLabel jLabelHMTitle;
    private javax.swing.JLabel jLabelHMTitle1;
    private javax.swing.JLabel jLabelShowDB;
    private javax.swing.JLabel jLabelStart;
    private javax.swing.JPanel jPanelAddr;
    private javax.swing.JPanel jPanelAddrInfo;
    private javax.swing.JPanel jPanelDB;
    private javax.swing.JPanel jPanelDBLoad;
    private javax.swing.JPanel jPanelFormat;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextAreaResults;
    private javax.swing.JTextField jTextFieldEnd;
    private javax.swing.JTextField jTextFieldStart;
    private javax.swing.JTextField jTextFieldZipcodes;
    private javax.swing.JPanel mapPanel;
    // End of variables declaration//GEN-END:variables

}
